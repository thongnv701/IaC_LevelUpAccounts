name: Complete Infrastructure Deployment

on:
  workflow_dispatch:
    inputs:
      deploy_terraform:
        description: 'Deploy Terraform infrastructure'
        type: boolean
        default: true
      deploy_nginx_ingress:
        description: 'Deploy Nginx Ingress'
        type: boolean
        default: true
      deploy_cert_manager:
        description: 'Deploy Cert Manager'
        type: boolean
        default: true
      deploy_app_of_apps:
        description: 'Deploy App of Apps'
        type: boolean
        default: true

jobs:
  deployment-start-notification:
    runs-on: ubuntu-latest
    environment: terraform
    steps:
      - name: Notify Deployment Started
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "üöÄ *Infrastructure Deployment Started!*",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üèóÔ∏è LevelUp Accounts Deployment"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚è≥ *Deployment has started!*\n\nThe following components will be deployed:"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*${{ github.event.inputs.deploy_terraform == 'true' && '‚úÖ' || '‚è≠Ô∏è' }} Terraform Infrastructure*"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*${{ github.event.inputs.deploy_nginx_ingress == 'true' && '‚úÖ' || '‚è≠Ô∏è' }} Nginx Ingress*"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*${{ github.event.inputs.deploy_cert_manager == 'true' && '‚úÖ' || '‚è≠Ô∏è' }} Cert Manager*"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*${{ github.event.inputs.deploy_app_of_apps == 'true' && '‚úÖ' || '‚è≠Ô∏è' }} App of Apps*"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üìà *Progress:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View GitHub Actions>\n‚è±Ô∏è *Estimated Time:* 10-15 minutes"
                  }
                }
              ]
            }' \
            ${{ secrets.SLACK_WEBHOOK_URL }}

  terraform-infra:
    needs: deployment-start-notification
    if: ${{ github.event.inputs.deploy_terraform == 'true' }}
    runs-on: ubuntu-latest
    environment: terraform
    env:
      TF_VAR_allowed_cidr: ${{ secrets.ALLOWED_CIDR }}
      TF_VAR_private_key_content: ${{ secrets.PRIVATE_KEY_CONTENT }}
      TF_VAR_rds_endpoint: ${{ secrets.RDS_ENDPOINT }}
      TF_VAR_rds_username: ${{ secrets.RDS_USERNAME }}
      TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}
      TF_VAR_route53_zone_id: ${{ secrets.ROUTE53_ZONE_ID }}
      TF_VAR_master_instance_type: ${{ secrets.MASTER_INSTANCE_TYPE }}
      TF_VAR_worker_instance_type: ${{ secrets.WORKER_INSTANCE_TYPE }}
      TF_VAR_worker_count: ${{ secrets.WORKER_COUNT }}
      TF_VAR_github_token: ${{ secrets.GIT_TOKEN }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: "1.3.0"

      - name: Download kubeconfig from S3 (if exists)
        run: aws s3 cp s3://my-terraform-backup-0701/kubeconfig ./terraform/modules/compute/kubeconfig || true

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        continue-on-error: true
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      - name: Upload kubeconfig to S3 and Artifacts
        if: success()
        run: |
          # Upload to S3 for backup
          aws s3 cp ./terraform/modules/compute/kubeconfig s3://my-terraform-backup-0701/kubeconfig
          # Create directory for artifact
          mkdir -p kubeconfig_artifact
          cp ./terraform/modules/compute/kubeconfig kubeconfig_artifact/

      - name: Upload kubeconfig as artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: kubeconfig_artifact/kubeconfig
          retention-days: 1

  nginx-ingress:
    needs: terraform-infra
    if: ${{ always() && (needs.terraform-infra.result == 'success' || needs.terraform-infra.result == 'skipped') && github.event.inputs.deploy_nginx_ingress == 'true' }}
    runs-on: ubuntu-latest
    environment: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"
      TF_VAR_allowed_cidr: ${{ secrets.ALLOWED_CIDR }}
      TF_VAR_private_key_content: ${{ secrets.PRIVATE_KEY_CONTENT }}
      TF_VAR_rds_endpoint: ${{ secrets.RDS_ENDPOINT }}
      TF_VAR_rds_username: ${{ secrets.RDS_USERNAME }}
      TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}
      TF_VAR_route53_zone_id: ${{ secrets.ROUTE53_ZONE_ID }}
      TF_VAR_master_instance_type: ${{ secrets.MASTER_INSTANCE_TYPE }}
      TF_VAR_worker_instance_type: ${{ secrets.WORKER_INSTANCE_TYPE }}
      TF_VAR_worker_count: ${{ secrets.WORKER_COUNT }}
      TF_VAR_github_token: ${{ secrets.GIT_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: "1.3.0"

      - name: Download kubeconfig from artifacts
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./terraform/modules/compute/

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Install Nginx Ingress via Terraform
        working-directory: ./terraform
        run: |
          terraform apply -target=helm_release.nginx_ingress -auto-approve
          terraform apply -target=null_resource.wait_for_nginx_ingress -auto-approve

  argocd-install:
    needs: nginx-ingress
    if: ${{ always() && (needs.nginx-ingress.result == 'success' || needs.nginx-ingress.result == 'skipped') }}
    runs-on: ubuntu-latest
    environment: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"
      TF_VAR_allowed_cidr: ${{ secrets.ALLOWED_CIDR }}
      TF_VAR_private_key_content: ${{ secrets.PRIVATE_KEY_CONTENT }}
      TF_VAR_rds_endpoint: ${{ secrets.RDS_ENDPOINT }}
      TF_VAR_rds_username: ${{ secrets.RDS_USERNAME }}
      TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}
      TF_VAR_route53_zone_id: ${{ secrets.ROUTE53_ZONE_ID }}
      TF_VAR_master_instance_type: ${{ secrets.MASTER_INSTANCE_TYPE }}
      TF_VAR_worker_instance_type: ${{ secrets.WORKER_INSTANCE_TYPE }}
      TF_VAR_worker_count: ${{ secrets.WORKER_COUNT }}
      TF_VAR_github_token: ${{ secrets.GIT_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: "1.3.0"

      - name: Download kubeconfig from artifacts
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./terraform/modules/compute/

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Install ArgoCD via Terraform
        working-directory: ./terraform
        run: |
          terraform apply -target=helm_release.argocd -auto-approve
          terraform apply -target=null_resource.wait_for_argocd -auto-approve

      - name: Get and Store ArgoCD Initial Password
        working-directory: ./terraform
        run: |
          # Wait for initial admin password to be available
          echo "Waiting for ArgoCD initial admin password..."
          for i in {1..30}; do
            if kubectl --kubeconfig=./modules/compute/kubeconfig -n argocd get secret argocd-initial-admin-secret &>/dev/null; then
              echo "Found initial admin password"
              break
            fi
            echo "Waiting for initial admin password... ($i/30)"
            sleep 10
          done
          
          # Get the initial admin password
          INITIAL_PASSWORD=$(kubectl --kubeconfig=./modules/compute/kubeconfig -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode)
          
          if [ -z "$INITIAL_PASSWORD" ]; then
            echo "Error: Could not retrieve initial admin password"
            exit 1
          fi
          
          # Save password to file
          echo "$INITIAL_PASSWORD" > argocd-admin-password.txt
          
          # Upload to S3
          aws s3 cp argocd-admin-password.txt s3://my-terraform-backup-0701/argocd-admin-password.txt
          
          # Make the password file publicly readable (for easy access via direct URL)
          # Note: This makes the password temporarily accessible via direct URL
          aws s3api put-object-acl --bucket my-terraform-backup-0701 --key argocd-admin-password.txt --acl public-read || echo "Warning: Could not make file public-readable. Use AWS CLI instead."
          
          # Generate a pre-signed URL for secure temporary access (24 hours)
          PRESIGNED_URL=$(aws s3 presign s3://my-terraform-backup-0701/argocd-admin-password.txt --expires-in 86400)
          echo "Pre-signed URL (24h): $PRESIGNED_URL"
          
          # Clean up local file
          rm argocd-admin-password.txt
          
          echo "-----------------------------------------------"
          echo "ArgoCD initial admin password has been stored in S3"
          echo "You can retrieve it using:"
          echo "1. Direct URL (if public): https://my-terraform-backup-0701.s3.ap-southeast-1.amazonaws.com/argocd-admin-password.txt"
          echo "2. AWS CLI: aws s3 cp s3://my-terraform-backup-0701/argocd-admin-password.txt -"
          echo "3. Pre-signed URL (24h): $PRESIGNED_URL"
          echo "-----------------------------------------------"

      - name: Setup GitHub Token for ArgoCD
        working-directory: ./terraform
        env:
          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}
        run: |
          echo "Setting up GitHub token for ArgoCD..."
          
          # Create GitHub token secret
          kubectl --kubeconfig=./modules/compute/kubeconfig create secret generic github-token \
            --namespace argocd \
            --from-literal=token="$GITHUB_TOKEN" \
            --dry-run=client -o yaml | kubectl --kubeconfig=./modules/compute/kubeconfig apply -f -
          
          # Update ArgoCD ConfigMap
          kubectl --kubeconfig=./modules/compute/kubeconfig patch configmap argocd-cm -n argocd \
            --type merge -p '{"data":{"github-token":"'"$GITHUB_TOKEN"'"}}'
          
          # Wait for ArgoCD to be ready
          echo "Waiting for ArgoCD to be ready..."
          kubectl --kubeconfig=./modules/compute/kubeconfig wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          
          echo "GitHub token setup completed"

      - name: Notify ArgoCD Installation Failed
        if: failure()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "‚ö†Ô∏è *ArgoCD Installation Failed!*",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚ùå *ArgoCD installation encountered an error.*"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üîç *Action Required:*\n‚Ä¢ Check the <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions logs>\n‚Ä¢ ArgoCD admin password may not be available\n‚Ä¢ Manual intervention may be required"
                  }
                }
              ]
            }' \
            ${{ secrets.SLACK_WEBHOOK_URL }}

  aws-secret-setup:
    needs: argocd-install
    if: ${{ always() && (needs.argocd-install.result == 'success' || needs.argocd-install.result == 'skipped') && github.event.inputs.deploy_cert_manager == 'true' }}
    runs-on: ubuntu-latest
    environment: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"
      ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
      AWS_HOSTED_ZONE_ID: ${{ secrets.AWS_HOSTED_ZONE_ID }}
      GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-1

      - name: Download kubeconfig from artifacts
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Create namespace and secrets
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          # Create cert-manager namespace directly
          echo "Creating cert-manager namespace..."
          kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
          
          # Create AWS credentials secret for Route53 DNS01 challenge
          echo "Creating Route53 credentials secret..."
          kubectl -n cert-manager create secret generic route53-credentials-secret \
            --from-literal=secret-access-key="$AWS_SECRET_ACCESS_KEY" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Create a secret with email and hosted zone ID for the cluster issuer
          echo "Creating configuration secret..."
          kubectl -n cert-manager create secret generic cert-manager-issuer-config \
            --from-literal=acme-email="$ACME_EMAIL" \
            --from-literal=hosted-zone-id="$AWS_HOSTED_ZONE_ID" \
            --from-literal=access-key-id="$AWS_ACCESS_KEY_ID" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Create level-up-accounts namespace (github-auth secret will be managed by External Secrets Operator)
          echo "Creating level-up-accounts namespace..."
          kubectl create namespace level-up-accounts --dry-run=client -o yaml | kubectl apply -f -
          
          # Create external-secrets-system namespace for External Secrets Operator
          echo "Creating external-secrets-system namespace..."
          kubectl create namespace external-secrets-system --dry-run=client -o yaml | kubectl apply -f -
          
          # Retrieve External Secrets AWS credentials from AWS Secrets Manager (created by Terraform)
          echo "Retrieving External Secrets AWS credentials from Secrets Manager..."
          
          # Check if the secret exists and is not marked for deletion
          SECRET_STATUS=$(aws secretsmanager describe-secret --secret-id "level-up-accounts/external-secrets-aws-credentials" --query 'DeletedDate' --output text 2>/dev/null || echo "NOT_FOUND")
          
          if [ "$SECRET_STATUS" = "NOT_FOUND" ]; then
            echo "Warning: External Secrets credentials secret not found in AWS Secrets Manager"
            echo "This is normal for first-time deployments or after terraform destroy"
            echo "Using main AWS credentials as fallback..."
            ESO_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
            ESO_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
          elif [ "$SECRET_STATUS" != "None" ]; then
            echo "Warning: External Secrets credentials secret is marked for deletion"
            echo "Secret deletion date: $SECRET_STATUS"
            echo "Attempting to restore the secret from deletion..."
            
            # Try to restore the secret
            if aws secretsmanager restore-secret --secret-id "level-up-accounts/external-secrets-aws-credentials" 2>/dev/null; then
              echo "‚úÖ Successfully restored the secret from deletion"
              echo "Waiting for secret to be available..."
              sleep 10
              
              # Try to retrieve the restored secret
              ESO_CREDENTIALS=$(aws secretsmanager get-secret-value --secret-id "level-up-accounts/external-secrets-aws-credentials" --query SecretString --output text 2>/dev/null || echo "FAILED")
              if [ "$ESO_CREDENTIALS" != "FAILED" ]; then
                ESO_ACCESS_KEY_ID=$(echo "$ESO_CREDENTIALS" | jq -r '.access_key_id' 2>/dev/null || echo "null")
                ESO_SECRET_ACCESS_KEY=$(echo "$ESO_CREDENTIALS" | jq -r '.secret_access_key' 2>/dev/null || echo "null")
                
                if [ "$ESO_ACCESS_KEY_ID" != "null" ] && [ "$ESO_SECRET_ACCESS_KEY" != "null" ] && [ -n "$ESO_ACCESS_KEY_ID" ] && [ -n "$ESO_SECRET_ACCESS_KEY" ]; then
                  echo "‚úÖ Successfully retrieved restored External Secrets credentials"
                else
                  echo "Warning: Restored secret has invalid credentials, using fallback..."
                  ESO_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
                  ESO_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
                fi
              else
                echo "Warning: Could not retrieve restored secret, using fallback..."
                ESO_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
                ESO_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
              fi
            else
              echo "Could not restore secret from deletion, using main AWS credentials as fallback..."
              ESO_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
              ESO_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
            fi
          else
            # Secret exists and is not marked for deletion, try to retrieve it
            ESO_CREDENTIALS=$(aws secretsmanager get-secret-value --secret-id "level-up-accounts/external-secrets-aws-credentials" --query SecretString --output text 2>/dev/null || echo "FAILED")
            
            if [ "$ESO_CREDENTIALS" = "FAILED" ]; then
              echo "Warning: Could not retrieve External Secrets credentials value"
              echo "Using main AWS credentials as fallback..."
              ESO_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
              ESO_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
            else
              ESO_ACCESS_KEY_ID=$(echo "$ESO_CREDENTIALS" | jq -r '.access_key_id' 2>/dev/null || echo "null")
              ESO_SECRET_ACCESS_KEY=$(echo "$ESO_CREDENTIALS" | jq -r '.secret_access_key' 2>/dev/null || echo "null")
              
              if [ "$ESO_ACCESS_KEY_ID" = "null" ] || [ "$ESO_SECRET_ACCESS_KEY" = "null" ] || [ -z "$ESO_ACCESS_KEY_ID" ] || [ -z "$ESO_SECRET_ACCESS_KEY" ]; then
                echo "Warning: External Secrets credentials are invalid or empty"
                echo "Using main AWS credentials as fallback..."
                ESO_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
                ESO_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
              else
                echo "‚úÖ Successfully retrieved dedicated External Secrets credentials"
              fi
            fi
          fi
          
          # Create AWS credentials secret for External Secrets Operator
          echo "Creating AWS credentials secret for External Secrets Operator..."
          echo "Using credentials with access key: ${ESO_ACCESS_KEY_ID:0:8}..."
          kubectl -n level-up-accounts create secret generic aws-credentials \
            --from-literal=access-key-id="$ESO_ACCESS_KEY_ID" \
            --from-literal=secret-access-key="$ESO_SECRET_ACCESS_KEY" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Verify the secret was created correctly
          echo "Verifying aws-credentials secret..."
          kubectl get secret aws-credentials -n level-up-accounts -o yaml | grep -E "access-key-id|secret-access-key" || echo "Failed to verify secret keys"
          
          # Wait for External Secrets Operator to be ready before proceeding
          echo "Waiting for External Secrets Operator to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets -n external-secrets-system || echo "ESO deployment wait timeout"
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets-webhook -n external-secrets-system || echo "ESO webhook wait timeout"
          kubectl wait --for=condition=available --timeout=300s deployment/external-secrets-cert-controller -n external-secrets-system || echo "ESO cert-controller wait timeout"
          
          # Give ESO additional time to initialize
          echo "Giving External Secrets Operator time to initialize..."
          sleep 30
          
          # Verify GitHub token exists in AWS Secrets Manager
          echo "Verifying GitHub token in AWS Secrets Manager..."
          if aws secretsmanager describe-secret --secret-id "level-up-accounts/github-token" >/dev/null 2>&1; then
            echo "‚úÖ GitHub token found in AWS Secrets Manager"
            GITHUB_TOKEN_VALUE=$(aws secretsmanager get-secret-value --secret-id "level-up-accounts/github-token" --query SecretString --output text | jq -r '.token' 2>/dev/null || echo "parsing failed")
            if [ ${#GITHUB_TOKEN_VALUE} -gt 10 ]; then
              echo "‚úÖ GitHub token appears valid (length: ${#GITHUB_TOKEN_VALUE})"
            else
              echo "‚ö†Ô∏è GitHub token may be invalid or empty"
            fi
          else
            echo "‚ùå GitHub token NOT found in AWS Secrets Manager"
            echo "This may cause External Secrets to fail"
          fi
          
          echo "AWS Credentials and configuration secrets created"
          
          # Important note about External Secrets credentials
          if [ "$ESO_ACCESS_KEY_ID" = "$AWS_ACCESS_KEY_ID" ]; then
            echo ""
            echo "‚ÑπÔ∏è  NOTE: Using main AWS credentials for External Secrets Operator"
            echo "   This is expected after 'terraform destroy' or first-time deployment"
            echo "   Terraform will create dedicated External Secrets credentials on next apply"
            echo "   The deployment will continue normally and External Secrets will work"
            echo ""
          fi
          
  app-of-apps-deploy:
    needs: [aws-secret-setup]
    if: ${{ always() && (needs.aws-secret-setup.result == 'success' || needs.aws-secret-setup.result == 'skipped') && github.event.inputs.deploy_app_of_apps == 'true' }}
    runs-on: ubuntu-latest
    environment: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"
      ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
      AWS_HOSTED_ZONE_ID: ${{ secrets.AWS_HOSTED_ZONE_ID }}
      GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-1

      - name: Download kubeconfig from artifacts
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Wait for ArgoCD to be ready (from Terraform)
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          # Check if ArgoCD namespace exists
          echo "Checking for ArgoCD namespace..."
          kubectl get namespace argocd || true
          
          # Wait for ArgoCD server to be ready
          echo "Waiting for ArgoCD server to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd || true

      - name: Apply app-of-apps.yaml
        env:
          KUBECONFIG: ./kubeconfig
        run: kubectl apply -f ./apps/app-of-apps.yaml

      - name: Wait for cert-manager CRDs
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          # Add the kubectl wait loop with timeout
          echo "Deploying apps through ArgoCD. This will take some time..."
          echo "Waiting for cert-manager CRDs to be established (timeout: 5 minutes)..."
          
          # Try for up to 5 minutes (30 x 10s = 300s = 5min)
          for i in {1..30}; do
            if kubectl get crd | grep -q "cert-manager.io"; then
              echo "cert-manager CRDs are installed"
              break
            fi
            echo "Waiting for cert-manager CRDs... ($i/30)"
            sleep 10
          done
          
          # Validate that the CRDs are actually installed
          if ! kubectl get crd | grep -q "cert-manager.io"; then
            echo "Warning: cert-manager CRDs were not detected, but continuing anyway."
          fi
          
          # Wait a bit more for the deployment to complete
          echo "Giving cert-manager some time to fully initialize..."
          sleep 30

      - name: Wait for cert-manager to be fully ready
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          echo "Waiting for cert-manager webhook to be ready..."
          
          # Wait for cert-manager deployment to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager -n cert-manager || echo "cert-manager deployment wait timed out"
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-webhook -n cert-manager || echo "cert-manager-webhook deployment wait timed out"
          kubectl wait --for=condition=available --timeout=300s deployment/cert-manager-cainjector -n cert-manager || echo "cert-manager-cainjector deployment wait timed out"
          
          # Wait for webhook service endpoints to be ready
          echo "Waiting for cert-manager-webhook service endpoints..."
          for i in {1..30}; do
            if kubectl get endpoints cert-manager-webhook -n cert-manager -o jsonpath='{.subsets[0].addresses[0].ip}' 2>/dev/null | grep -q .; then
              echo "cert-manager-webhook endpoints are ready"
              break
            fi
            echo "Waiting for cert-manager-webhook endpoints... ($i/30)"
            sleep 10
          done
          
          # Additional wait to ensure webhook is responding
          echo "Giving cert-manager webhook additional time to be fully ready..."
          sleep 30

      - name: Patch ClusterIssuer with credentials
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          # Wait for the ClusterIssuer to be created and patch it
          echo "Waiting for ClusterIssuer to be created by ArgoCD..."
          for i in {1..30}; do
            if kubectl get clusterissuer letsencrypt-prod 2>/dev/null; then
              echo "ClusterIssuer found, attempting to patch with credentials..."
              
              # Try patching with retries in case webhook is still stabilizing
              for retry in {1..5}; do
                if kubectl patch clusterissuer letsencrypt-prod --type=json -p='[
                  {"op": "replace", "path": "/spec/acme/email", "value": "'"$ACME_EMAIL"'"},
                  {"op": "replace", "path": "/spec/acme/solvers/0/dns01/route53/hostedZoneID", "value": "'"$AWS_HOSTED_ZONE_ID"'"},
                  {"op": "replace", "path": "/spec/acme/solvers/0/dns01/route53/accessKeyID", "value": "'"$AWS_ACCESS_KEY_ID"'"}
                ]' 2>/dev/null; then
                  echo "ClusterIssuer patched successfully!"
                  break 2
                else
                  echo "Patch attempt $retry failed, retrying in 15 seconds..."
                  sleep 15
                fi
              done
              
              echo "Failed to patch ClusterIssuer after 5 attempts"
              break
            fi
            echo "Waiting for ClusterIssuer... ($i/30)"
            sleep 10
          done
          
          # If ClusterIssuer isn't found after the wait, report but don't fail
          if ! kubectl get clusterissuer letsencrypt-prod 2>/dev/null; then
            echo "Warning: ClusterIssuer 'letsencrypt-prod' was not found after waiting. It may be created later by ArgoCD."
          fi

      - name: Debug External Secrets Status
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          echo "=== DEBUGGING EXTERNAL SECRETS ==="
          
          echo "1. External Secrets Operator pods:"
          kubectl get pods -n external-secrets-system || echo "No ESO pods found"
          
          echo "2. External Secrets Operator logs (last 20 lines):"
          kubectl logs -n external-secrets-system deployment/external-secrets --tail=20 || echo "Could not get ESO logs"
          
          echo "3. SecretStore status:"
          kubectl get secretstore -n level-up-accounts || echo "No SecretStore found"
          kubectl describe secretstore aws-secrets-manager -n level-up-accounts || echo "Could not describe SecretStore"
          
          echo "4. ExternalSecret status:"
          kubectl get externalsecret -n level-up-accounts || echo "No ExternalSecret found"
          kubectl describe externalsecret github-auth-external -n level-up-accounts || echo "Could not describe ExternalSecret"
          
          echo "5. Generated github-auth secret:"
          kubectl get secret github-auth -n level-up-accounts || echo "github-auth secret not found"
          
          echo "6. AWS credentials secret:"
          kubectl get secret aws-credentials -n level-up-accounts || echo "aws-credentials secret not found"
          
          echo "7. Testing AWS Secrets Manager access manually:"
          AWS_ACCESS_KEY_ID=$(kubectl get secret aws-credentials -n level-up-accounts -o jsonpath='{.data.access-key-id}' | base64 -d)
          AWS_SECRET_ACCESS_KEY=$(kubectl get secret aws-credentials -n level-up-accounts -o jsonpath='{.data.secret-access-key}' | base64 -d)
          echo "AWS credentials length check: access_key=${#AWS_ACCESS_KEY_ID}, secret_key=${#AWS_SECRET_ACCESS_KEY}"
          
          echo "8. Testing direct AWS Secrets Manager access:"
          export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
          export AWS_DEFAULT_REGION="ap-southeast-1"
          aws secretsmanager describe-secret --secret-id "level-up-accounts/github-token" && echo "‚úÖ Direct access works" || echo "‚ùå Direct access failed"
          
          echo "9. Creating a test SecretStore to validate configuration:"
          cat <<EOF | kubectl apply -f - || echo "Failed to create test SecretStore"
          apiVersion: external-secrets.io/v1beta1
          kind: SecretStore
          metadata:
            name: test-aws-secrets-manager
            namespace: level-up-accounts
          spec:
            provider:
              aws:
                service: SecretsManager
                region: ap-southeast-1
                auth:
                  secretRef:
                    accessKeyID:
                      name: aws-credentials
                      key: access-key-id
                    secretAccessKey:
                      name: aws-credentials
                      key: secret-access-key
          EOF
          
          echo "10. Waiting for test SecretStore to be ready:"
          for i in {1..30}; do
            STATUS=$(kubectl get secretstore test-aws-secrets-manager -n level-up-accounts -o jsonpath='{.status.conditions[0].status}' 2>/dev/null || echo "Unknown")
            echo "Test SecretStore status: $STATUS ($i/30)"
            if [ "$STATUS" = "True" ]; then
              echo "‚úÖ Test SecretStore is ready!"
              break
            fi
            sleep 10
          done
          
          echo "=== END DEBUG ==="

  dns-management:
    needs: [terraform-infra]
    if: ${{ always() && (needs.terraform-infra.result == 'success' || needs.terraform-infra.result == 'skipped') }}
    runs-on: ubuntu-latest
    environment: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"
      TF_VAR_allowed_cidr: ${{ secrets.ALLOWED_CIDR }}
      TF_VAR_private_key_content: ${{ secrets.PRIVATE_KEY_CONTENT }}
      TF_VAR_rds_endpoint: ${{ secrets.RDS_ENDPOINT }}
      TF_VAR_rds_username: ${{ secrets.RDS_USERNAME }}
      TF_VAR_rds_password: ${{ secrets.RDS_PASSWORD }}
      TF_VAR_route53_zone_id: ${{ secrets.ROUTE53_ZONE_ID }}
      TF_VAR_master_instance_type: ${{ secrets.MASTER_INSTANCE_TYPE }}
      TF_VAR_worker_instance_type: ${{ secrets.WORKER_INSTANCE_TYPE }}
      TF_VAR_worker_count: ${{ secrets.WORKER_COUNT }}
      TF_VAR_github_token: ${{ secrets.GIT_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: "1.3.0"

      - name: Download kubeconfig from artifacts
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./terraform/modules/compute/

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Apply DNS Configuration with Terraform
        working-directory: ./terraform
        run: |
          terraform apply -target=data.aws_route53_zone.main -target=data.aws_instances.k3s_instances -target=aws_route53_record.service_records -auto-approve
          
          # Output the created DNS records more reliably without using jq
          echo "DNS entries updated through Terraform:"
          terraform output dns_records | sed 's/{//g' | sed 's/}//g' | sed 's/"//g' | tr -d '\n' | sed 's/,/\n/g'

  slack-notification:
    needs: [terraform-infra, nginx-ingress, argocd-install, aws-secret-setup, app-of-apps-deploy, dns-management]
    if: always()
    runs-on: ubuntu-latest
    environment: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-southeast-1"
    steps:
      - name: Send Deployment Completion Notification
        run: |
          # Determine overall status
          if [[ "${{ needs.terraform-infra.result }}" == "success" && "${{ needs.nginx-ingress.result }}" == "success" && "${{ needs.argocd-install.result }}" == "success" && "${{ needs.aws-secret-setup.result }}" == "success" && "${{ needs.app-of-apps-deploy.result }}" == "success" && "${{ needs.dns-management.result }}" == "success" ]]; then
            STATUS="‚úÖ SUCCESS"
            COLOR="good"
            MESSAGE="üéâ *Complete Infrastructure Deployment Successful!*"
            DETAILS="All components have been deployed successfully. Your infrastructure is ready to use!"
          else
            STATUS="‚ùå FAILED"
            COLOR="danger"
            MESSAGE="‚ö†Ô∏è *Deployment had some issues!*"
            DETAILS="Some components failed to deploy. Please check the GitHub Actions logs for details."
          fi
          
          # Create the JSON payload
          cat > slack_payload.json << EOF
          {
            "text": "$MESSAGE",
            "attachments": [
              {
                "color": "$COLOR",
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": "üöÄ LevelUp Accounts Infrastructure Deployment"
                    }
                  },
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "$DETAILS"
                    }
                  },
                  {
                    "type": "section",
                    "fields": [
                      {
                        "type": "mrkdwn",
                        "text": "*üèóÔ∏è Terraform Infrastructure:*\n\`${{ needs.terraform-infra.result }}\`"
                      },
                      {
                        "type": "mrkdwn",
                        "text": "*üåê Nginx Ingress:*\n\`${{ needs.nginx-ingress.result }}\`"
                      },
                      {
                        "type": "mrkdwn",
                        "text": "*üîÑ ArgoCD Installation:*\n\`${{ needs.argocd-install.result }}\`"
                      },
                      {
                        "type": "mrkdwn",
                        "text": "*üîê AWS Secret Setup:*\n\`${{ needs.aws-secret-setup.result }}\`"
                      },
                      {
                        "type": "mrkdwn",
                        "text": "*üì¶ App of Apps:*\n\`${{ needs.app-of-apps-deploy.result }}\`"
                      },
                      {
                        "type": "mrkdwn",
                        "text": "*üåç DNS Management:*\n\`${{ needs.dns-management.result }}\`"
                      }
                    ]
                  }
                ]
              }
            ]
          }
          EOF
          
          # Send the notification
          curl -X POST -H 'Content-type: application/json' \
            --data @slack_payload.json \
            ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Send Service URLs and Credentials Info
        if: ${{ needs.terraform-infra.result == 'success' && needs.argocd-install.result == 'success' }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "üîó *Service URLs & Access Information*",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üåê *Available Services:*"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*üîÑ ArgoCD:*\n<https://argocd.thongit.space|argocd.thongit.space>"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*üìä Grafana:*\n<https://grafana.thongit.space|grafana.thongit.space>"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*üöÄ API:*\n<https://api.thongit.space|api.thongit.space>"
                    }
                  ]
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üîë *ArgoCD Admin Access:*\n‚Ä¢ *Username:* `admin`\n‚Ä¢ *Password URL:* https://my-terraform-backup-0701.s3.ap-southeast-1.amazonaws.com/argocd-admin-password.txt\n‚Ä¢ *AWS CLI:* `aws s3 cp s3://my-terraform-backup-0701/argocd-admin-password.txt -`\n‚Ä¢ *Secure Access:* Check logs for pre-signed URL (24h)"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üìã *Quick Access:*\n```# ArgoCD Password (Direct URL - if public)\ncurl https://my-terraform-backup-0701.s3.ap-southeast-1.amazonaws.com/argocd-admin-password.txt\n\n# ArgoCD Password (AWS CLI)\naws s3 cp s3://my-terraform-backup-0701/argocd-admin-password.txt -\n\n# ArgoCD Password (Pre-signed URL - most secure)\n# Check deployment logs for the temporary secure link\n\n# Get kubeconfig\naws s3 cp s3://my-terraform-backup-0701/kubeconfig ./kubeconfig```"
                  }
                }
              ]
            }' \
            ${{ secrets.SLACK_WEBHOOK_URL }}

  deployment-summary:
    needs: [terraform-infra, nginx-ingress, argocd-install, aws-secret-setup, app-of-apps-deploy, dns-management, slack-notification]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Summarize Deployment
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Infrastructure | ${{ needs.terraform-infra.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Nginx Ingress | ${{ needs.nginx-ingress.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ArgoCD Installation | ${{ needs.argocd-install.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AWS Secret Setup | ${{ needs.aws-secret-setup.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| App of Apps | ${{ needs.app-of-apps-deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Management | ${{ needs.dns-management.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.terraform-infra.result }}" == "success" && "${{ needs.nginx-ingress.result }}" == "success" && "${{ needs.argocd-install.result }}" == "success" && "${{ needs.aws-secret-setup.result }}" == "success" && "${{ needs.app-of-apps-deploy.result }}" == "success" && "${{ needs.dns-management.result }}" == "success" ]]; then
            echo "‚úÖ **Complete deployment successful!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "You can now access:" >> $GITHUB_STEP_SUMMARY
            echo "- ArgoCD: https://argocd.thongit.space" >> $GITHUB_STEP_SUMMARY
            echo "- Grafana: https://grafana.thongit.space" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è **Deployment had some issues!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs for more details." >> $GITHUB_STEP_SUMMARY
          fi 
